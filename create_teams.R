# Create a vector of team sizes.
# Arguments:
#   1. n -> total number of people.
#   2. min -> minimum size for a team.
#   3. max -> maximum size for a team.
#   4. pref -> preferred size for a team.
# Returns:
#   1. team_sizes -> vector of group sizes.
create_team_sizes = function(n, min, max, pref) {
  if (min > max) {
    stop('minimum team size greater than maximum team size.')
  }
  if (min < pref - 1) {
    stop('minimum team size should be within one of the preference team size.')
  }
  if (max > pref + 1) {
    stop('maximum team size should be within one of the preference team size.')
  }
  lower = pref - 1
  upper = pref + 1
  for(i in seq(floor(n / pref), 1, -1)) {
    rem = n - (i * pref)
    if (rem %% lower == 0 & lower >= min) {
      team_sizes = numeric(i + floor(rem / lower))
      for (j in 1:(i + floor(rem / lower))) {
        if (j < (i + 1)) {
          team_sizes[j] = pref
        }
        else {
          team_sizes[j] = lower
        }
      }
      return(team_sizes)
    }
    if (rem %% upper == 0 & upper <= max) {
      team_sizes = numeric(i + floor(rem / upper))
      for (j in 1:(i + floor(rem / upper))) {
        if (j < (i + 1)) {
          team_sizes[j] = pref
        }
        else {
          team_sizes[j] = upper
        }
      }
      return(team_sizes)
    }
  }
  if (pref + 1 > max) {
    stop('cannot find proper size')
  }
  return(create_team_sizes(n, min, max, pref+1))
}

# Pretty print for team sizes.
# Arguments:
#   1. team_sizes -> vector of team sizes (should be generated by create_team_sizes).
print_team_sizes = function(team_sizes) {
  size_counts = as_tibble(table(team_sizes))
  phrase = 'You have created'
  for(i in 1:nrow(size_counts)) {
    if (i == nrow(size_counts)) {
      phrase = paste0(phrase, ' and ', size_counts$n[i], ' teams of ', size_counts$team_sizes[i], '.')
    }
    else {
      if (i != 1) {
        phrase = paste0(phrase, ',')
      }
      phrase = paste0(phrase, ' ',  size_counts$n[i], ' teams of ', size_counts$team_sizes[i])
    }
  }
  print(phrase)
}

# Create teams using a snake draft format.
# Arguments: 
#   1. data -> data frame of student information.
#   2. team_sizes -> vector of team sizes (should be generated by create_team_sizes).
# Returns:
#   1. teams -> data frame of teams where each column represents a team.
snake_draft = function(data, team_sizes) {
  teams = tibble(.rows=max(team_sizes))
  for (i in 1:length(team_sizes)) {
    teams[[paste0('team_', as.character(i))]] = ''
  }
  row = 1
  col = 1
  direction = 1
  for (i in 1:nrow(data)) {
    teams[row, col] = data$names[i]
    if (i %% ncol(teams) == 0) {
      direction = -direction
      row = row + 1
    }
    else {
      col = col + direction
    }
  }
  return(teams)
}

# Generate team statistics for criterion and diversity.
# Arguments:
#   1. data -> data frame of student information.
#   2. teams -> data frame of teams.
#   3. criterion -> vector of criterion in order of importance.
#   4. diversity_factor -> diversity column name.
#   5. diversity_flag -> diverse value.
# Returns:
#   1. stats -> data frame of team statistics.
team_stats = function(data, teams, criterion, diversity_factor=FALSE, diversity_flag=FALSE) {
  stats = tibble(.rows=ncol(teams))
  stats[['team']] = numeric(1)
  stats[['size']] = numeric(1)
  for(i in 1:length(criterion)) {
    stats[[paste0(criterion[i], '_average')]] = numeric(1)
    stats[[paste0(criterion[i], '_total')]] = numeric(1)
  }
  if (diversity_factor != FALSE) {
    stats[[diversity_factor]] = numeric(1)
  }
  for(i in 1:ncol(teams)) {
    data_group = data %>%
      filter(names %in% as.vector(teams[[i]]))
    stats[['team']][i] = i
    stats[['size']][i] = sum(teams[,i] != '')
    for(j in 1:length(criterion)) {
      stats[[paste0(criterion[j], '_average')]][i] = mean(data_group[[criterion[j]]])
      stats[[paste0(criterion[j], '_total')]][i] = sum(data_group[[criterion[j]]])
    }
    if (diversity_factor != FALSE) {
      data_diversity = data_group %>%
        filter(get(diversity_factor) == diversity_flag)
      stats[[diversity_factor]][i] = nrow(data_diversity)
    }
  }
  return(stats)
}

# Compare standard deviation of criterion columns in different team statistic data frames.
# Arguments:
#   1. stats -> data frame (should be generated by team_stats).
#   2. stats_updated -> data frame (should be generated by team_stats).
#   3. criterion -> vector of criterion in order of importance.
# Returns:
#   1. bool -> do the updated statistics have lower standard deviation for all criterion columns?
stat_cmp = function(stats, stats_updated, criterion) {
  for(i in 1:length(criterion)) {
    avg = paste0(criterion[i], '_average')
    avg_sd = sd(stats[[avg]])
    avg_sd_updated = sd(stats_updated[[avg]])
    if (avg_sd_updated > avg_sd) {
      return(FALSE)
    }
    tot = paste0(criterion[i], '_total')
    tot_sd = sd(stats[[tot]])
    tot_sd_updated = sd(stats_updated[[tot]])
    if (tot_sd_updated > tot_sd) {
      return(FALSE)
    }
  }
  return(TRUE)
}

# Optimize sd of criterion columns for teams.
# Arguments:
#   1. data -> data frame of student information.
#   2. teams -> data frame of teams.
#   3. criterion -> vector of criterion in order of importance.
#   4. depth -> number of iterations.
# Returns:
#   1. teams -> optimized version of teams.
teams_optimize = function(data, teams, criterion, method='comprehensive', depth=1, minutes=5) {
  if (method == 'comprehensive') {
    runs = 1
    update = TRUE
    stats = team_stats(data, teams, criterion)
    while(runs <= depth & update == TRUE) {
      update = FALSE
      for(i in 1:ncol(teams)) {
        for(j in 1:ncol(teams)) {
          if (i < j) {
            teams_updated = teams
            for(k in 1:length(teams_updated[[i]])) {
              for(l in 1:length(teams_updated[[j]])) {
                if (teams_updated[[i]][k] != '' & teams_updated[[j]][l] != '') {
                  temp = teams_updated[[i]][k]
                  teams_updated[[i]][k] = teams_updated[[j]][l]
                  teams_updated[[j]][l] = temp
                  stats_updated = team_stats(data, teams_updated, criterion)
                  if (stat_cmp(stats, stats_updated, criterion) == TRUE) {
                    teams = teams_updated
                    stats = team_stats(data, teams, criterion)
                    update = TRUE
                  }
                }
              }
            }
          }
        }
      }
      runs = runs + 1
    }
  }
  if (method == 'random') {
    start = proc.time()
    t = proc.time() - start
    stats = team_stats(data, teams, criterion)
    while (t[[3]] / 60 < minutes) {
      ts = sample(1:ncol(teams), 2)
      t1 = ts[1]
      t2 = ts[2]
      e1 = sample(1:sum(teams[[t1]]!=''), 1)
      e2 = sample(1:sum(teams[[t2]]!=''), 1)
      teams_updated = teams
      temp = teams_updated[[t1]][e1]
      teams_updated[[t1]][e1] = teams_updated[[t2]][e2]
      teams_updated[[t2]][e2] = temp
      stats_updated = team_stats(data, teams_updated, criterion)
      if (stat_cmp(stats, stats_updated, criterion) == TRUE) {
        teams = teams_updated
        stats = team_stats(data, teams, criterion)
      }
      t = proc.time() - start
    }
  }
  return(teams)
}

# Correct teams based on diversity factor.
# Teams should have zero or more than one student with the diversity flag.
# Arguments:
#   1. data -> data frame of student information.
#   2. teams -> data frame of teams.
#   3. criterion -> vector of criterion in order of importance.
#   4. diversity_factor -> diversity column name.
#   5. diversity_flag -> diverse value.
# Returns:
#   1. teams -> diversified version of teams. 
teams_diverse = function(data, teams, criterion, diversity_factor, diversity_flag) {
  stats_div = team_stats(data, teams, criterion, diversity_factor, diversity_flag)
  teams_one = filter(stats_div, get(diversity_factor)==1)[['team']]
  teams_zero = filter(stats_div, get(diversity_factor)==0)[['team']]
  zero_names = c()
  if (length(teams_zero) > 0) {
    for(i in 1:length(teams_zero)) {
      zero_names = c(zero_names, teams[[teams_zero[i]]][teams[[teams_zero[i]]] != ''])
    }
  }
  while(length(teams_one) > 0) {
    closeness = tibble(n1 = '', n2 = '', .rows = length(teams_one))
    for(i in 1:length(criterion)) {
      closeness[[criterion[i]]] = 0
    }
    for(i in 1:length(teams_one)) {
      team = teams[[teams_one[i]]][teams[[teams_one[i]]] != '']
      div = filter(data, names %in% team & get(diversity_factor) == diversity_flag)
      other = filter(data, !(names %in% team) &
                       !(names %in% zero_names) &
                       get(diversity_factor) != diversity_flag) %>%
        select(names, all_of(criterion))
      for(j in 1:length(criterion)) {
        div_value = div[[criterion[j]]]
        other[[criterion[j]]] = abs(other[[criterion[j]]] - div_value)
        other = filter(other, get(criterion[j]) == min(get(criterion[j])))
      }
      other = other[1,]
      closeness[['n1']][i] = div[['names']]
      closeness[['n2']][i] = other[['names']]
      closeness[i,3:ncol(closeness)] = other[1,2:ncol(other)]
    }
    for(i in seq(length(criterion), 1, -1)) {
      closeness = closeness %>%
        arrange(get(criterion[i]))
    }
    index_div = which(teams==closeness[['n1']][1], arr.ind=TRUE)
    index_other = which(teams==closeness[['n2']][1], arr.ind=TRUE)
    temp = teams[index_div[[1]], index_div[[2]]]
    teams[index_div[[1]], index_div[[2]]] = teams[index_other[[1]], index_other[[2]]]
    teams[index_other[[1]], index_other[[2]]] = temp
    stats_div = team_stats(data, teams, criterion, diversity_factor, diversity_flag)
    teams_one = filter(stats_div, get(diversity_factor)==1)[['team']]
    teams_zero = filter(stats_div, get(diversity_factor)==0)[['team']]
    zero_names = c()
    if (length(teams_zero) > 0) {
      for(i in 1:length(teams_zero)) {
        zero_names = c(zero_names, teams[[teams_zero[i]]])
      }
    }
  }
  return(teams)
}

# Create teams for TBL.
# Arguments:
#   1. data -> data frame with names, criterion columns, and possibly sex or major.
#   2. criterion -> vector of criterion in order of importance.
#   3. team_min -> minimum team size.
#   4. team_max -> maximum team size.
#   5. team_pref -> prefered size for each team.
#   6. optimize -> should teams be optimized after the snake draft?
#   7. method -> optimization method.
#     method='comprehensive' -> check every permutation of name switches for local optimization.
#     method='random' -> check random permuations of name switches for local optimization.
#   8. depth -> optimization depth for comprehensive method.
#   9. minutes -> random method time.
#   10. diversity_factor -> diversity column name.
#   11. diversity_flag -> diversity value.
# Return:
#   1. teams -> data frame of teams where each column is a team.
team_creation = function(data, criterion, 
                         team_min, team_max, team_pref,
                         optimize=TRUE, method='comprehensive', depth=1, minutes=5,
                         diversity_factor=FALSE, diversity_flag=FALSE) {
  team_sizes = create_team_sizes(nrow(data), team_min, team_max, team_pref)
  print_team_sizes(team_sizes)
  for (i in seq(length(criterion), 1, -1)) {
    data = arrange(data, get(criterion[i]))
  }
  teams = snake_draft(data, team_sizes)
  if(optimize == TRUE) {
    if (method == 'comprehensive') {
      teams = teams_optimize(data, teams, criterion, method=method, depth=depth)
    }
    if (method == 'random') {
      teams = teams_optimize(data, teams, criterion, method=method, minutes=minutes)
    }
  }
  if (diversity_factor != FALSE) {
    teams = teams_diverse(data, teams, criterion, diversity_factor, diversity_flag)
  }
  return(teams)
}

# -------------------------------------------------------------------------
# ---------------------- Testing -------------------------------------------
# -------------------------------------------------------------------------

library(tibble)
library(tidyverse)

# ---------------------------------------------------------------
# -------------------- Test 1 ------------------------------------
# ----------------------------------------------------------------

# Data includes 15 males and 10 females. 
# Major, number of stat courses, and number of cs courses are all randomized. 
t1 = tibble(names = c('Johnny', 'Jackson', 'Josh', 'Joseph', 'Jack', 
                      'Joel', 'Jason', 'Jonah', 'Justin', 'Joe',
                      'Jamal', 'Jaylen', 'Jared', 'Jimmy', 'Jerome',
                      'Jan', 'Jennifer', 'Julia', 'Josie', 'Jill',
                      'Jenna', 'Jasmine', 'Joy', 'Jessica', 'Judy'),
            sex = c(sample('M', 15, replace=TRUE), sample('F', 10, replace=TRUE)),
            stat_major = sample(c('T', 'F'), 25, replace=TRUE),
            stat_classes = floor(10*runif(25)),
            cs_classes = floor(10*runif(25)))
criterion = c('stat_classes', 'cs_classes')

# Comprehensive optimization with depth 1.
t1_comp = team_creation(data=t1, 
                        criterion=criterion, 
                        team_min=3, 
                        team_max=4, 
                        team_pref=4,
                        method='comprehensive',
                        depth=1)
t1_comp_stats = team_stats(data=t1, 
                           teams=t1_comp, 
                           criterion=criterion)
# Random optimization for 1 minute.
t1_rand = team_creation(data=t1, 
                        criterion=criterion, 
                        team_min=3, 
                        team_max=4, 
                        team_pref=4,
                        method='random',
                        minutes=1)
t1_rand_stats = team_stats(data=t1, 
                           teams=t1_rand, 
                           criterion=criterion)
# Sex diversity.
t1_sex = team_creation(data=t1, 
                       criterion=criterion, 
                       team_min=3, 
                       team_max=4, 
                       team_pref=4, 
                       optimize=FALSE,
                       diversity_factor='sex', 
                       diversity_flag='F')
t1_sex_stats = team_stats(data=t1, 
                          teams=t1_sex, 
                          criterion=criterion, 
                          diversity_factor='sex', 
                          diversity_flag='F')
# Major diversity.
t1_major = team_creation(data=t1, 
                         criterion=criterion, 
                         team_min=3, 
                         team_max=4, 
                         team_pref=4, 
                         optimize=FALSE,
                         diversity_factor='stat_major', 
                         diversity_flag='F')
t1_major_stats = team_stats(data=t1, 
                            teams=t1_major, 
                            criterion=criterion, 
                            diversity_factor='stat_major', 
                            diversity_flag='F')

# ----------------------------------------------------------------
# ------------- Test 2 --------------------------------------------
# --------------------------------------------------------------

# Larger test set. 
name_generator = function(n) {
  names = character(n)
  for(i in 1:length(names)) {
    len = sample(4:7, 1)
    names[i] = intToUtf8(sample(97:122, 5, replace=TRUE))
  }
  return(names)
}
n = 101
t2 = tibble(names = name_generator(n),
            sex=sample(c('M', 'F'), n, replace=TRUE),
            stat_major = sample(c('T', 'F'), n, replace=TRUE),
            stat_classes = floor(10*runif(n)),
            cs_classes = floor(10*runif(n)))

# Comprehensive optimization with depth 1 (this takes a long time).
t2_comp = team_creation(data=t2, 
                        criterion=criterion, 
                        team_min=4, 
                        team_max=5, 
                        team_pref=5,
                        method='comprehensive',
                        depth=1)
t2_comp_stats = team_stats(data=t2, 
                           teams=t2_comp, 
                           criterion=criterion)
# Random optimization for 1 minute.
t2_rand = team_creation(data=t2, 
                        criterion=criterion, 
                        team_min=4, 
                        team_max=5, 
                        team_pref=5,
                        method='random',
                        minutes=1)
t2_rand_stats = team_stats(data=t2, 
                           teams=t2_rand, 
                           criterion=criterion)
# Sex diversity.
t2_sex = team_creation(data=t2, 
                       criterion=criterion, 
                       team_min=4, 
                       team_max=5, 
                       team_pref=5, 
                       optimize=FALSE,
                       diversity_factor='sex', 
                       diversity_flag='F')
t2_sex_stats = team_stats(data=t2, 
                          teams=t2_sex, 
                          criterion=criterion, 
                          diversity_factor='sex', 
                          diversity_flag='F')
# Major diversity.
t2_major = team_creation(data=t2, 
                         criterion=criterion, 
                         team_min=4, 
                         team_max=5, 
                         team_pref=5, 
                         optimize=FALSE,
                         diversity_factor='stat_major', 
                         diversity_flag='F')
t2_major_stats = team_stats(data=t2, 
                            teams=t2_major, 
                            criterion=criterion, 
                            diversity_factor='stat_major', 
                            diversity_flag='F')
